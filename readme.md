<h2>Topics Covered:</h2>
1. Introduction to OOPs<br/>
2. Benefits of using OOPs<br/>
3. Object Oriented Languages vs Object Based Languages<br/>
4. Real-world examples of OOPs<br/>
5. Advantages and Disadvantages of OOPs<br/>
6. Object<br/>
7. Class<br/>
8. Empty Classes<br/>
9. Access Modifiers (or Access Specifiers)<br/>
10. Getters and Setters<br/>
11. Data Alignment<br/>
12. Data Structure Padding<br/>
13. Static Memory Allocation vs Dynamic Memory Allocation<br/>
14. Constructors and Destructors<br/>
15. Shallow Copy and Deep Copy<br/>
16. Copy Assignment Operator(=)<br/>
17. Encapsulation<br/>
18. Inheritance<br/>
19. Modes of Inheritance<br/>
20. Types of Inheritance<br/>
21. Inheritance Ambiguity<br/>
22. Polymorphism<br/>
23. Abstraction<br/>
24. Encapsulation vs Abstraction<br/>
25. Friend Function<br/>
26. Virtual Function<br/>
27. PureVirtual Function<br/>
28. Abstract Classes<br/>
29. Dynamic Binding<br/>
30. this keyword<br/>
31. const keyword<br/>
32. static keyword<br/>
33. virtual keyword<br/>
34. new keyword<br/>
35. final keyword<br/>
36. explicit keyword<br/>
37. super keyword<br/>
38. abstract keyword<br/>
39. Initializer List<br/>
40. Diamond Problem / Deadly Diamond of Death<br/>
41. Programming Paradigms<br/>
42. Limitations of Inheritance<br/>
43. Exceptional Handling in C++<br/>
44. Garbage Collection in OOPs<br/>
45. Method Overloading vs Method Overriding<br/>
46. Singleton Classes<br/>
47. Smart Pointers<br/>
48. Friend Class<br/>
49. Friend Function<br/>
50. Inline Function<br/>
51. Persistent Object vs Non-Persistent Object<br/>
52. Virtual Inheritance<br/>
53. Virtual Pointers(vptr) and Virtual Function Table(vtable)<br/>
54. Factory Method<br/>
55. Virtual Destructors<br/>
56. Pointers and References<br/>
57. Templates in C++<br/>
58. Generics in Java<br/>
59. volatile keyword in C<br/>
60. final vs finally vs finalize in Java<br/>
61. Private Constructor<br/>
62. Reflection of Java Classes<br/>